# Generated by Django ... on ...
from django.db import migrations
import re

# --- Define your normalization function HERE ---
# (Copy the exact function you use in models.py/views.py)
def normalize_area_name(name):
    if not name: return ""
    name = name.lower()
    name = re.sub(r'\s+', '', name)
    return name
# --- End normalization function ---

def forwards_func(apps, schema_editor):
    """
    Populates display_name, normalizes name, and handles potential duplicates.
    """
    Area = apps.get_model('news_app', 'Area')
    Article = apps.get_model('news_app', 'Article')
    Post = apps.get_model('news_app', 'Post') # Assuming Post has FK/M2M to Area
    db_alias = schema_editor.connection.alias

    processed_normalized_names = {} # Keep track of names we've already assigned

    print("\nStarting Area data migration...")

    # Iterate through existing areas using the specific migration state's model
    # Order by ID to have a consistent "first" entry in case of duplicates
    for area in Area.objects.using(db_alias).order_by('id').all():
        original_name = area.name # Keep the original name for display
        normalized_name = normalize_area_name(original_name)

        print(f"Processing Area ID {area.id}: Original='{original_name}', Normalized='{normalized_name}'")

        if not normalized_name:
            print(f"  WARNING: Area ID {area.id} ('{original_name}') normalizes to empty string. Deleting or requires manual fix.")
            # Decide how to handle this: delete? assign a placeholder?
            # Option: Delete it if it has no relations
            # if not area.articles.exists() and not area.posts.exists(): # Adjust if Post uses FK
            #    print(f"  Deleting Area ID {area.id} as it normalized to empty and has no relations.")
            #    area.delete()
            continue # Skip processing further for now

        if normalized_name in processed_normalized_names:
            # --- DUPLICATE DETECTED ---
            canonical_area_id = processed_normalized_names[normalized_name]
            print(f"  DUPLICATE: '{normalized_name}' already assigned to Area ID {canonical_area_id}. Merging Area ID {area.id} into {canonical_area_id}.")

            try:
                canonical_area = Area.objects.using(db_alias).get(id=canonical_area_id)

                # 1. Re-assign related objects (Articles)
                articles_to_move = area.articles.all()
                print(f"    Moving {articles_to_move.count()} articles...")
                for article in articles_to_move:
                    # Remove from old area, add to new. Use canonical_area object.
                    area.articles.remove(article) # Important if using M2M default through table
                    canonical_area.articles.add(article)

                # 2. Re-assign related objects (Posts) - Adjust based on your Post<->Area link
                # If Post has M2M 'posts' on Area:
                posts_to_move_m2m = area.posts.all()
                print(f"    Moving {posts_to_move_m2m.count()} posts (M2M)...")
                for post in posts_to_move_m2m:
                        area.posts.remove(post)
                        canonical_area.posts.add(post)

                # OR: If Post has FK 'area' to Area (using related_name='posts_direct'):
                # posts_to_move_fk = Post.objects.using(db_alias).filter(area=area)
                # print(f"    Moving {posts_to_move_fk.count()} posts (FK)...")
                # posts_to_move_fk.update(area=canonical_area)


                # 3. Optionally: Update URLModel if it links to Area


                # 4. Delete the duplicate Area object
                print(f"    Deleting duplicate Area ID {area.id} ('{original_name}').")
                area.delete()

            except Area.DoesNotExist:
                    print(f"  ERROR: Canonical Area ID {canonical_area_id} not found during merge. Skipping merge for Area ID {area.id}.")
            except Exception as e:
                    print(f"  ERROR merging Area ID {area.id}: {e}. Manual cleanup might be required.")


        else:
            # --- NO DUPLICATE (or first occurrence) ---
            print(f"  Assigning normalized name '{normalized_name}' to Area ID {area.id}.")
            # Store this as the canonical entry for this normalized name
            processed_normalized_names[normalized_name] = area.id

            # Update the area instance
            area.name = normalized_name
            # Set display_name - use original, maybe title-cased?
            area.display_name = original_name.title() # Adjust capitalization if needed
            area.save(update_fields=['name', 'display_name'])
            print(f"  Updated Area ID {area.id}: Name='{area.name}', DisplayName='{area.display_name}'")


    print("Area data migration finished.")


def reverse_func(apps, schema_editor):
    # You might want to make this reversible if possible,
    # but reversing normalization and merging is complex and often skipped.
    # If you do, you'd try to revert names and potentially split merged areas,
    # which is very difficult.
    print("Reverse migration for Area normalization not implemented.")
    pass

class Migration(migrations.Migration):

    dependencies = [
        # Add the previous migration file here (the one that added display_name)
        # e.g., ('news_app', '000X_auto_...'),
        ('news_app', '0022_area_display_name'), # Replace with your actual previous migration
    ]

    operations = [
        migrations.RunPython(forwards_func, reverse_func),
    ]
